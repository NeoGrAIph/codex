diff --git a/codex-rs/core/src/codex.rs b/codex-rs/core/src/codex.rs
index 8567c9286..8bb4eb424 100644
--- a/codex-rs/core/src/codex.rs
+++ b/codex-rs/core/src/codex.rs
@@ -1,9 +1,12 @@
 use std::collections::HashMap;
 use std::collections::HashSet;
 use std::fmt::Debug;
+use std::path::Path;
 use std::path::PathBuf;
 use std::sync::Arc;
+use std::sync::atomic::AtomicBool;
 use std::sync::atomic::AtomicU64;
+use std::sync::atomic::Ordering;
 
 use crate::AuthManager;
 use crate::CodexAuth;
@@ -12,6 +15,7 @@ use crate::agent::AgentControl;
 use crate::agent::AgentStatus;
 use crate::agent::MAX_THREAD_SPAWN_DEPTH;
 use crate::agent::agent_status_from_event;
+use crate::agent::registry::AgentRegistry;
 use crate::analytics_client::AnalyticsEventsClient;
 use crate::analytics_client::build_track_events_context;
 use crate::compact;
@@ -97,6 +101,7 @@ use tracing::trace_span;
 use tracing::warn;
 
 use crate::ModelProviderInfo;
+use crate::WireApi;
 use crate::client::ModelClient;
 use crate::client::ModelClientSession;
 use crate::client_common::Prompt;
@@ -132,6 +137,7 @@ use crate::mentions::build_connector_slug_counts;
 use crate::mentions::build_skill_name_counts;
 use crate::mentions::collect_explicit_app_paths;
 use crate::mentions::collect_tool_mentions_from_messages;
+use crate::model_provider_info::CHAT_WIRE_API_DEPRECATION_SUMMARY;
 use crate::project_doc::get_user_instructions;
 use crate::proposed_plan_parser::ProposedPlanParser;
 use crate::proposed_plan_parser::ProposedPlanSegment;
@@ -222,6 +228,24 @@ use codex_utils_readiness::Readiness;
 use codex_utils_readiness::ReadinessFlag;
 use tokio::sync::watch;
 
+/// Instructions for the parent agent on how to use multi-agent collaboration tools.
+const COLLAB_MULTI_AGENT_PROMPT: &str = include_str!("../templates/collab/experimental_prompt.md");
+
+const COLLAB_PROMPT_FILENAME: &str = "colab_prompt.md";
+
+/// Resolves the collab prompt by checking for user overrides in the standard
+/// `.codex/agents/` directories. Repo-local takes precedence over user-global,
+/// matching the agent registry resolution order.
+fn resolve_collab_prompt(cwd: &Path, codex_home: &Path) -> Option<String> {
+    let candidates = [
+        cwd.join(".codex/agents").join(COLLAB_PROMPT_FILENAME),
+        codex_home.join("agents").join(COLLAB_PROMPT_FILENAME),
+    ];
+    candidates
+        .iter()
+        .find_map(|path| std::fs::read_to_string(path).ok())
+}
+
 /// The high-level interface to the Codex system.
 /// It operates as a queue pair where you send submissions and receive events.
 pub struct Codex {
@@ -245,6 +269,31 @@ pub struct CodexSpawnOk {
 
 pub(crate) const INITIAL_SUBMIT_ID: &str = "";
 pub(crate) const SUBMISSION_CHANNEL_CAPACITY: usize = 64;
+static CHAT_WIRE_API_DEPRECATION_EMITTED: AtomicBool = AtomicBool::new(false);
+
+fn maybe_push_chat_wire_api_deprecation(
+    config: &Config,
+    post_session_configured_events: &mut Vec<Event>,
+) {
+    if config.model_provider.wire_api != WireApi::Chat {
+        return;
+    }
+
+    if CHAT_WIRE_API_DEPRECATION_EMITTED
+        .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
+        .is_err()
+    {
+        return;
+    }
+
+    post_session_configured_events.push(Event {
+        id: INITIAL_SUBMIT_ID.to_owned(),
+        msg: EventMsg::DeprecationNotice(DeprecationNoticeEvent {
+            summary: CHAT_WIRE_API_DEPRECATION_SUMMARY.to_string(),
+            details: None,
+        }),
+    });
+}
 
 impl Codex {
     /// Spawn a new [`Codex`] and initialize the session.
@@ -260,6 +309,11 @@ impl Codex {
         agent_control: AgentControl,
         dynamic_tools: Vec<DynamicToolSpec>,
     ) -> CodexResult<CodexSpawnOk> {
+        // Seed built-in agents if needed
+        if let Err(e) = crate::agent::registry::seed_builtin_agents(&config.codex_home) {
+            warn!("Failed to seed built-in agents: {e}");
+        }
+
         let (tx_sub, rx_sub) = async_channel::bounded(SUBMISSION_CHANNEL_CAPACITY);
         let (tx_event, rx_event) = async_channel::unbounded();
 
@@ -276,7 +330,7 @@ impl Codex {
         if let SessionSource::SubAgent(SubAgentSource::ThreadSpawn { depth, .. }) = session_source
             && depth >= MAX_THREAD_SPAWN_DEPTH
         {
-            config.features.disable(Feature::Collab);
+            config.features.disable(Feature::FnMultiAgents);
         }
 
         let enabled_skills = loaded_skills.enabled_skills();
@@ -348,7 +402,7 @@ impl Codex {
         // TODO (aibrahim): Consolidate config.model and config.model_reasoning_effort into config.collaboration_mode
         // to avoid extracting these fields separately and constructing CollaborationMode here.
         let collaboration_mode = CollaborationMode {
-            mode: ModeKind::Default,
+            mode: ModeKind::Custom,
             settings: Settings {
                 model: model.clone(),
                 reasoning_effort: config.model_reasoning_effort,
@@ -769,18 +823,50 @@ impl Session {
             model_info.slug.as_str(),
         );
         let session_source = session_configuration.session_source.clone();
+        let cwd = session_configuration.cwd.clone();
         let auth_manager_for_context = auth_manager;
         let provider_for_context = provider;
         let otel_manager_for_context = otel_manager;
         let per_turn_config = Arc::new(per_turn_config);
 
+        let (agent_registry_present, agent_descriptions, agent_name_descriptions) =
+            if per_turn_config.features.enabled(Feature::FnMultiAgents) {
+                let registry = AgentRegistry::load_for_config(per_turn_config.as_ref());
+                let agent_registry_present = !registry.agents.is_empty();
+                let agent_descriptions = if agent_registry_present {
+                    Some(registry.format_agent_descriptions())
+                } else {
+                    None
+                };
+                let agent_name_descriptions = if agent_registry_present {
+                    let formatted = registry.format_agent_name_descriptions();
+                    if formatted.is_empty() {
+                        None
+                    } else {
+                        Some(formatted)
+                    }
+                } else {
+                    None
+                };
+                (
+                    agent_registry_present,
+                    agent_descriptions,
+                    agent_name_descriptions,
+                )
+            } else {
+                (false, None, None)
+            };
         let tools_config = ToolsConfig::new(&ToolsConfigParams {
             model_info: &model_info,
             features: &per_turn_config.features,
             web_search_mode: per_turn_config.web_search_mode,
+            tool_allowlist: per_turn_config.tool_allowlist.as_deref(),
+            tool_denylist: per_turn_config.tool_denylist.as_deref(),
+            agent_registry_present,
+            agent_descriptions,
+            agent_name_descriptions,
         });
 
-        let cwd = session_configuration.cwd.clone();
         TurnContext {
             sub_id,
             config: per_turn_config.clone(),
@@ -945,6 +1031,7 @@ impl Session {
                 }),
             });
         }
+        maybe_push_chat_wire_api_deprecation(&config, &mut post_session_configured_events);
         maybe_push_unstable_features_warning(&config, &mut post_session_configured_events);
 
         let auth = auth.as_ref();
@@ -1180,22 +1267,32 @@ impl Session {
                 }
 
                 // If resuming, warn when the last recorded model differs from the current one.
-                let curr = turn_context.model_info.slug.as_str();
-                if let Some(prev) = Self::last_model_name(&rollout_items, curr) {
-                    warn!("resuming session with different model: previous={prev}, current={curr}");
-                    self.send_event(
-                        &turn_context,
-                        EventMsg::Warning(WarningEvent {
-                            message: format!(
-                                "This session was recorded with model `{prev}` but is resuming with `{curr}`. \
+                if let Some(prev) = rollout_items.iter().rev().find_map(|it| {
+                    if let RolloutItem::TurnContext(ctx) = it {
+                        Some(ctx.model.as_str())
+                    } else {
+                        None
+                    }
+                }) {
+                    let curr = turn_context.model_info.slug.as_str();
+                    if prev != curr {
+                        warn!(
+                            "resuming session with different model: previous={prev}, current={curr}"
+                        );
+                        self.send_event(
+                            &turn_context,
+                            EventMsg::Warning(WarningEvent {
+                                message: format!(
+                                    "This session was recorded with model `{prev}` but is resuming with `{curr}`. \
                          Consider switching back to `{prev}` as it may affect Codex performance."
-                            ),
-                        }),
-                    )
-                    .await;
+                                ),
+                            }),
+                        )
+                        .await;
 
-                    let mut state = self.state.lock().await;
-                    state.pending_resume_previous_model = Some(prev.to_string());
+                        let mut state = self.state.lock().await;
+                        state.pending_resume_previous_model = Some(prev.to_string());
+                    }
                 }
 
                 // Always add response items to conversation history
@@ -1385,13 +1482,10 @@ impl Session {
             model_info,
             sub_id,
         );
-
         if let Some(final_schema) = final_output_json_schema {
             turn_context.final_output_json_schema = final_schema;
         }
-        let turn_context = Arc::new(turn_context);
-        turn_context.spawn_turn_metadata_header_task();
-        turn_context
+        Arc::new(turn_context)
     }
 
     pub(crate) async fn new_default_turn(&self) -> Arc<TurnContext> {
@@ -1521,9 +1615,11 @@ impl Session {
         resumed_model: Option<&str>,
         next: &TurnContext,
     ) -> Option<ResponseItem> {
-        let previous_model =
-            resumed_model.or_else(|| previous.map(|prev| prev.model_info.slug.as_str()))?;
-        if previous_model == next.model_info.slug {
+        let previous_model = resumed_model
+            .map(str::to_string)
+            .or_else(|| previous.map(|prev| prev.model_info.slug.clone()))?;
+        let current_model = next.model_info.slug.as_str();
+        if previous_model == current_model {
             return None;
         }
 
@@ -1534,7 +1630,6 @@ impl Session {
 
         Some(DeveloperInstructions::model_switch_message(model_instructions).into())
     }
-
     fn build_settings_update_items(
         &self,
         previous_context: Option<&Arc<TurnContext>>,
@@ -2060,11 +2155,12 @@ impl Session {
             items.push(DeveloperInstructions::new(developer_instructions.to_string()).into());
         }
         // Add developer instructions from collaboration_mode if they exist and are non-empty
-        let (collaboration_mode, base_instructions) = {
+        let (collaboration_mode, base_instructions, codex_home) = {
             let state = self.state.lock().await;
             (
                 state.session_configuration.collaboration_mode.clone(),
                 state.session_configuration.base_instructions.clone(),
+                state.session_configuration.codex_home.clone(),
             )
         };
         if let Some(collab_instructions) =
@@ -2072,6 +2168,11 @@ impl Session {
         {
             items.push(collab_instructions.into());
         }
+        if self.features.enabled(Feature::FnMultiAgents) {
+            let prompt = resolve_collab_prompt(&turn_context.cwd, &codex_home)
+                .unwrap_or_else(|| COLLAB_MULTI_AGENT_PROMPT.to_string());
+            items.push(DeveloperInstructions::new(prompt).into());
+        }
         if self.features.enabled(Feature::Personality)
             && let Some(personality) = turn_context.personality
         {
@@ -2641,22 +2742,6 @@ async fn submission_loop(sess: Arc<Session>, config: Arc<Config>, rx_sub: Receiv
             Op::ListSkills { cwds, force_reload } => {
                 handlers::list_skills(&sess, sub.id.clone(), cwds, force_reload).await;
             }
-            Op::ListRemoteSkills => {
-                handlers::list_remote_skills(&sess, &config, sub.id.clone()).await;
-            }
-            Op::DownloadRemoteSkill {
-                hazelnut_id,
-                is_preload,
-            } => {
-                handlers::download_remote_skill(
-                    &sess,
-                    &config,
-                    sub.id.clone(),
-                    hazelnut_id,
-                    is_preload,
-                )
-                .await;
-            }
             Op::Undo => {
                 handlers::undo(&sess, sub.id.clone()).await;
             }
@@ -2723,12 +2808,9 @@ mod handlers {
     use codex_protocol::protocol::Event;
     use codex_protocol::protocol::EventMsg;
     use codex_protocol::protocol::ListCustomPromptsResponseEvent;
-    use codex_protocol::protocol::ListRemoteSkillsResponseEvent;
     use codex_protocol::protocol::ListSkillsResponseEvent;
     use codex_protocol::protocol::McpServerRefreshConfig;
     use codex_protocol::protocol::Op;
-    use codex_protocol::protocol::RemoteSkillDownloadedEvent;
-    use codex_protocol::protocol::RemoteSkillSummary;
     use codex_protocol::protocol::ReviewDecision;
     use codex_protocol::protocol::ReviewRequest;
     use codex_protocol::protocol::SkillsListEntry;
@@ -2794,7 +2876,7 @@ mod handlers {
             } => {
                 let collaboration_mode = collaboration_mode.or_else(|| {
                     Some(CollaborationMode {
-                        mode: ModeKind::Default,
+                        mode: ModeKind::Custom,
                         settings: Settings {
                             model: model.clone(),
                             reasoning_effort: effort,
@@ -3087,77 +3169,6 @@ mod handlers {
         sess.send_event_raw(event).await;
     }
 
-    pub async fn list_remote_skills(sess: &Session, config: &Arc<Config>, sub_id: String) {
-        let response = crate::skills::remote::list_remote_skills(config)
-            .await
-            .map(|skills| {
-                skills
-                    .into_iter()
-                    .map(|skill| RemoteSkillSummary {
-                        id: skill.id,
-                        name: skill.name,
-                        description: skill.description,
-                    })
-                    .collect::<Vec<_>>()
-            });
-
-        match response {
-            Ok(skills) => {
-                let event = Event {
-                    id: sub_id,
-                    msg: EventMsg::ListRemoteSkillsResponse(ListRemoteSkillsResponseEvent {
-                        skills,
-                    }),
-                };
-                sess.send_event_raw(event).await;
-            }
-            Err(err) => {
-                let event = Event {
-                    id: sub_id,
-                    msg: EventMsg::Error(ErrorEvent {
-                        message: format!("failed to list remote skills: {err}"),
-                        codex_error_info: Some(CodexErrorInfo::Other),
-                    }),
-                };
-                sess.send_event_raw(event).await;
-            }
-        }
-    }
-
-    pub async fn download_remote_skill(
-        sess: &Session,
-        config: &Arc<Config>,
-        sub_id: String,
-        hazelnut_id: String,
-        is_preload: bool,
-    ) {
-        match crate::skills::remote::download_remote_skill(config, hazelnut_id.as_str(), is_preload)
-            .await
-        {
-            Ok(result) => {
-                let event = Event {
-                    id: sub_id,
-                    msg: EventMsg::RemoteSkillDownloaded(RemoteSkillDownloadedEvent {
-                        id: result.id,
-                        name: result.name,
-                        path: result.path,
-                    }),
-                };
-                sess.send_event_raw(event).await;
-            }
-            Err(err) => {
-                let event = Event {
-                    id: sub_id,
-                    msg: EventMsg::Error(ErrorEvent {
-                        message: format!("failed to download remote skill {hazelnut_id}: {err}"),
-                        codex_error_info: Some(CodexErrorInfo::Other),
-                    }),
-                };
-                sess.send_event_raw(event).await;
-            }
-        }
-    }
-
     pub async fn undo(sess: &Arc<Session>, sub_id: String) {
         let turn_context = sess.new_default_turn_with_sub_id(sub_id).await;
         sess.spawn_task(turn_context, Vec::new(), UndoTask::new())
@@ -3391,10 +3402,42 @@ async fn spawn_review_thread(
         .disable(crate::features::Feature::WebSearchRequest)
         .disable(crate::features::Feature::WebSearchCached);
     let review_web_search_mode = WebSearchMode::Disabled;
+    let (agent_registry_present, agent_descriptions, agent_name_descriptions) =
+        if review_features.enabled(Feature::FnMultiAgents) {
+            let registry = AgentRegistry::load_for_config(config.as_ref());
+            let agent_registry_present = !registry.agents.is_empty();
+            let agent_descriptions = if agent_registry_present {
+                Some(registry.format_agent_descriptions())
+            } else {
+                None
+            };
+            let agent_name_descriptions = if agent_registry_present {
+                let formatted = registry.format_agent_name_descriptions();
+                if formatted.is_empty() {
+                    None
+                } else {
+                    Some(formatted)
+                }
+            } else {
+                None
+            };
+            (
+                agent_registry_present,
+                agent_descriptions,
+                agent_name_descriptions,
+            )
+        } else {
+            (false, None, None)
+        };
     let tools_config = ToolsConfig::new(&ToolsConfigParams {
         model_info: &review_model_info,
         features: &review_features,
         web_search_mode: Some(review_web_search_mode),
+        tool_allowlist: config.tool_allowlist.as_deref(),
+        tool_denylist: config.tool_denylist.as_deref(),
+        agent_registry_present,
+        agent_descriptions,
+        agent_name_descriptions,
     });
 
     let review_prompt = resolved.prompt.clone();
@@ -3449,7 +3492,7 @@ async fn spawn_review_thread(
         tool_call_gate: Arc::new(ReadinessFlag::new()),
         dynamic_tools: parent_turn_context.dynamic_tools.clone(),
         truncation_policy: model_info.truncation_policy.into(),
-        turn_metadata_header: parent_turn_context.turn_metadata_header.clone(),
+        turn_metadata_header: OnceCell::new(),
     };
 
     // Seed the child task with the review prompt as the initial user message.
@@ -5283,7 +5326,7 @@ mod tests {
         let model_info = ModelsManager::construct_model_info_offline(model.as_str(), &config);
         let reasoning_effort = config.model_reasoning_effort;
         let collaboration_mode = CollaborationMode {
-            mode: ModeKind::Default,
+            mode: ModeKind::Custom,
             settings: Settings {
                 model,
                 reasoning_effort,
@@ -5366,7 +5409,7 @@ mod tests {
         let model_info = ModelsManager::construct_model_info_offline(model.as_str(), &config);
         let reasoning_effort = config.model_reasoning_effort;
         let collaboration_mode = CollaborationMode {
-            mode: ModeKind::Default,
+            mode: ModeKind::Custom,
             settings: Settings {
                 model,
                 reasoning_effort,
@@ -5639,7 +5682,7 @@ mod tests {
         let model_info = ModelsManager::construct_model_info_offline(model.as_str(), &config);
         let reasoning_effort = config.model_reasoning_effort;
         let collaboration_mode = CollaborationMode {
-            mode: ModeKind::Default,
+            mode: ModeKind::Custom,
             settings: Settings {
                 model,
                 reasoning_effort,
@@ -5769,7 +5812,7 @@ mod tests {
         let model_info = ModelsManager::construct_model_info_offline(model.as_str(), &config);
         let reasoning_effort = config.model_reasoning_effort;
         let collaboration_mode = CollaborationMode {
-            mode: ModeKind::Default,
+            mode: ModeKind::Custom,
             settings: Settings {
                 model,
                 reasoning_effort,
