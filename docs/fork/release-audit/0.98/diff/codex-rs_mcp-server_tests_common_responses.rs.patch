diff --git a/codex-rs/mcp-server/tests/common/responses.rs b/codex-rs/mcp-server/tests/common/responses.rs
index 48a575a4c..0a9183c04 100644
--- a/codex-rs/mcp-server/tests/common/responses.rs
+++ b/codex-rs/mcp-server/tests/common/responses.rs
@@ -1,7 +1,5 @@
-use std::path::Path;
-
-use core_test_support::responses;
 use serde_json::json;
+use std::path::Path;
 
 pub fn create_shell_command_sse_response(
     command: Vec<String>,
@@ -9,39 +7,90 @@ pub fn create_shell_command_sse_response(
     timeout_ms: Option<u64>,
     call_id: &str,
 ) -> anyhow::Result<String> {
+    // The `arguments` for the `shell_command` tool is a serialized JSON object.
     let command_str = shlex::try_join(command.iter().map(String::as_str))?;
-    let arguments = serde_json::to_string(&json!({
+    let tool_call_arguments = serde_json::to_string(&json!({
         "command": command_str,
         "workdir": workdir.map(|w| w.to_string_lossy()),
-        "timeout_ms": timeout_ms,
+        "timeout_ms": timeout_ms
     }))?;
-    let response_id = format!("resp-{call_id}");
-    Ok(responses::sse(vec![
-        responses::ev_response_created(&response_id),
-        responses::ev_function_call(call_id, "shell_command", &arguments),
-        responses::ev_completed(&response_id),
-    ]))
+    let tool_call = json!({
+        "choices": [
+            {
+                "delta": {
+                    "tool_calls": [
+                        {
+                            "id": call_id,
+                            "function": {
+                                "name": "shell_command",
+                                "arguments": tool_call_arguments
+                            }
+                        }
+                    ]
+                },
+                "finish_reason": "tool_calls"
+            }
+        ]
+    });
+
+    let sse = format!(
+        "data: {}\n\ndata: DONE\n\n",
+        serde_json::to_string(&tool_call)?
+    );
+    Ok(sse)
 }
 
 pub fn create_final_assistant_message_sse_response(message: &str) -> anyhow::Result<String> {
-    let response_id = "resp-final";
-    Ok(responses::sse(vec![
-        responses::ev_response_created(response_id),
-        responses::ev_assistant_message("msg-final", message),
-        responses::ev_completed(response_id),
-    ]))
+    let assistant_message = json!({
+        "choices": [
+            {
+                "delta": {
+                    "content": message
+                },
+                "finish_reason": "stop"
+            }
+        ]
+    });
+
+    let sse = format!(
+        "data: {}\n\ndata: DONE\n\n",
+        serde_json::to_string(&assistant_message)?
+    );
+    Ok(sse)
 }
 
 pub fn create_apply_patch_sse_response(
     patch_content: &str,
     call_id: &str,
 ) -> anyhow::Result<String> {
+    // Use shell_command to call apply_patch with heredoc format
     let command = format!("apply_patch <<'EOF'\n{patch_content}\nEOF");
-    let arguments = serde_json::to_string(&json!({ "command": command }))?;
-    let response_id = format!("resp-{call_id}");
-    Ok(responses::sse(vec![
-        responses::ev_response_created(&response_id),
-        responses::ev_function_call(call_id, "shell_command", &arguments),
-        responses::ev_completed(&response_id),
-    ]))
+    let tool_call_arguments = serde_json::to_string(&json!({
+        "command": command
+    }))?;
+
+    let tool_call = json!({
+        "choices": [
+            {
+                "delta": {
+                    "tool_calls": [
+                        {
+                            "id": call_id,
+                            "function": {
+                                "name": "shell_command",
+                                "arguments": tool_call_arguments
+                            }
+                        }
+                    ]
+                },
+                "finish_reason": "tool_calls"
+            }
+        ]
+    });
+
+    let sse = format!(
+        "data: {}\n\ndata: DONE\n\n",
+        serde_json::to_string(&tool_call)?
+    );
+    Ok(sse)
 }
