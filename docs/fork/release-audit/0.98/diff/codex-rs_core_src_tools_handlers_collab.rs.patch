diff --git a/codex-rs/core/src/tools/handlers/collab.rs b/codex-rs/core/src/tools/handlers/collab.rs
index 3110204d2..4fb5ba52e 100644
--- a/codex-rs/core/src/tools/handlers/collab.rs
+++ b/codex-rs/core/src/tools/handlers/collab.rs
@@ -82,18 +82,30 @@ impl ToolHandler for CollabHandler {
 
 mod spawn {
     use super::*;
-    use crate::agent::AgentRole;
+    use crate::agent::registry::AgentRegistry;
 
     use crate::agent::exceeds_thread_spawn_depth_limit;
     use crate::agent::next_thread_spawn_depth;
+    use crate::agent::status::is_final;
+    use codex_protocol::openai_models::ReasoningEffort;
     use codex_protocol::protocol::SessionSource;
     use codex_protocol::protocol::SubAgentSource;
     use std::sync::Arc;
+    use std::time::Duration;
+    use tokio::sync::watch::Receiver;
+    use tokio::time::Instant;
 
     #[derive(Debug, Deserialize)]
     struct SpawnAgentArgs {
         message: String,
-        agent_type: Option<AgentRole>,
+        /// Agent type to spawn (e.g., worker, reviewer). Resolved from registry.
+        agent_type: Option<String>,
+        /// Optional agent_name within agent_type for alternate instructions.
+        agent_name: Option<String>,
+        /// Optional model override with highest priority.
+        model: Option<String>,
+        /// Optional reasoning effort override with highest priority.
+        reasoning_effort: Option<ReasoningEffort>,
     }
 
     #[derive(Debug, Serialize)]
@@ -108,13 +120,18 @@ mod spawn {
         arguments: String,
     ) -> Result<ToolOutput, FunctionCallError> {
         let args: SpawnAgentArgs = parse_arguments(&arguments)?;
-        let agent_role = args.agent_type.unwrap_or(AgentRole::Default);
+
         let prompt = args.message;
+        let agent_type = args.agent_type.clone();
+        let agent_name = args.agent_name.clone();
+        let model_override = args.model.clone();
+        let reasoning_effort_override = args.reasoning_effort;
         if prompt.trim().is_empty() {
             return Err(FunctionCallError::RespondToModel(
                 "Empty message can't be sent to an agent".to_string(),
             ));
         }
+        let registry = AgentRegistry::load_for_config(turn.config.as_ref());
         let session_source = turn.session_source.clone();
         let child_depth = next_thread_spawn_depth(&session_source);
         if exceeds_thread_spawn_depth_limit(child_depth) {
@@ -138,9 +155,30 @@ mod spawn {
             turn.as_ref(),
             child_depth,
         )?;
-        agent_role
-            .apply_to_config(&mut config)
-            .map_err(FunctionCallError::RespondToModel)?;
+
+        // Resolve agent by agent_type from registry
+        if let Some(agent_type) = args.agent_type.as_deref() {
+            let agent_def = registry.find(agent_type).ok_or_else(|| {
+                let available: Vec<_> = registry.agents.iter().map(|a| a.name.as_str()).collect();
+                FunctionCallError::RespondToModel(format!(
+                    "Agent type '{}' not found. Available: {}",
+                    agent_type,
+                    available.join(", ")
+                ))
+            })?;
+
+            agent_def
+                .apply_to_config(&mut config, args.agent_name.as_deref())
+                .map_err(FunctionCallError::RespondToModel)?;
+        }
+
+        if let Some(model_override) = model_override.as_deref() {
+            validate_model_override(&session, turn.as_ref(), model_override)?;
+            config.model = Some(model_override.to_string());
+        }
+        if let Some(reasoning_effort_override) = reasoning_effort_override {
+            config.model_reasoning_effort = Some(reasoning_effort_override);
+        }
 
         let result = session
             .services
@@ -151,6 +189,8 @@ mod spawn {
                 Some(SessionSource::SubAgent(SubAgentSource::ThreadSpawn {
                     parent_thread_id: session.conversation_id,
                     depth: child_depth,
+                    agent_type: args.agent_type.clone(),
+                    agent_name: args.agent_name.clone(),
                 })),
             )
             .await
@@ -166,16 +206,27 @@ mod spawn {
             .send_event(
                 &turn,
                 CollabAgentSpawnEndEvent {
-                    call_id,
+                    call_id: call_id.clone(),
                     sender_thread_id: session.conversation_id,
                     new_thread_id,
                     prompt,
                     status,
+                    agent_type: agent_type.clone(),
+                    agent_name: agent_name.clone(),
                 }
                 .into(),
             )
             .await;
         let new_thread_id = result?;
+        maybe_spawn_status_relay(
+            session.clone(),
+            turn.clone(),
+            call_id.clone(),
+            new_thread_id,
+            agent_type,
+            agent_name,
+        )
+        .await;
 
         let content = serde_json::to_string(&SpawnAgentResult {
             agent_id: new_thread_id.to_string(),
@@ -189,6 +240,181 @@ mod spawn {
             success: Some(true),
         })
     }
+
+    async fn maybe_spawn_status_relay(
+        session: Arc<Session>,
+        turn: Arc<TurnContext>,
+        call_id: String,
+        receiver_thread_id: ThreadId,
+        agent_type: Option<String>,
+        agent_name: Option<String>,
+    ) {
+        let Ok(status_rx) = session
+            .services
+            .agent_control
+            .subscribe_status(receiver_thread_id)
+            .await
+        else {
+            return;
+        };
+
+        spawn_status_relay_task(
+            session,
+            turn,
+            call_id,
+            receiver_thread_id,
+            agent_type,
+            agent_name,
+            status_rx,
+        );
+    }
+
+    fn validate_model_override(
+        session: &Session,
+        turn: &TurnContext,
+        model_override: &str,
+    ) -> Result<(), FunctionCallError> {
+        let Ok(models) = session
+            .services
+            .models_manager
+            .try_list_models(turn.config.as_ref())
+        else {
+            return Ok(());
+        };
+        if models.is_empty() {
+            return Ok(());
+        }
+        let matches = models
+            .iter()
+            .any(|preset| preset.model == model_override || preset.id == model_override);
+        if matches {
+            return Ok(());
+        }
+        let available = models
+            .iter()
+            .map(|preset| preset.model.as_str())
+            .collect::<Vec<_>>()
+            .join(", ");
+        Err(FunctionCallError::RespondToModel(format!(
+            "Model '{model_override}' not found. Available: {available}"
+        )))
+    }
+
+    pub(super) fn spawn_status_relay_task(
+        session: Arc<Session>,
+        turn: Arc<TurnContext>,
+        call_id: String,
+        receiver_thread_id: ThreadId,
+        agent_type: Option<String>,
+        agent_name: Option<String>,
+        mut status_rx: Receiver<AgentStatus>,
+    ) {
+        let start = Instant::now();
+        tokio::spawn(async move {
+            let mut last_emitted: Option<AgentStatus> = None;
+            loop {
+                let status = status_rx.borrow().clone();
+                if last_emitted.as_ref() != Some(&status) {
+                    emit_status_change(
+                        &session,
+                        &turn,
+                        &call_id,
+                        receiver_thread_id,
+                        agent_type.as_deref(),
+                        agent_name.as_deref(),
+                        start.elapsed(),
+                        &status,
+                    )
+                    .await;
+                    last_emitted = Some(status.clone());
+                }
+
+                if is_final(&status) {
+                    break;
+                }
+
+                if status_rx.changed().await.is_err() {
+                    break;
+                }
+            }
+        });
+    }
+
+    async fn emit_status_change(
+        session: &Session,
+        turn: &TurnContext,
+        call_id: &str,
+        receiver_thread_id: ThreadId,
+        agent_type: Option<&str>,
+        agent_name: Option<&str>,
+        elapsed: Duration,
+        status: &AgentStatus,
+    ) {
+        let agent_label = agent_label(agent_type, agent_name);
+        let elapsed = format_elapsed(elapsed);
+        let base = format!("agent {agent_label} ({receiver_thread_id}) [{call_id}]");
+
+        let message = match status {
+            AgentStatus::PendingInit => return,
+            AgentStatus::Running => format!("{base} started"),
+            AgentStatus::Completed(last) => {
+                let preview = last
+                    .as_deref()
+                    .map(|text| preview_single_line(text, 240))
+                    .filter(|text| !text.is_empty());
+                match preview {
+                    Some(preview) => format!("{base} completed in {elapsed}: {preview}"),
+                    None => format!("{base} completed in {elapsed}"),
+                }
+            }
+            AgentStatus::Errored(err) => {
+                let preview = preview_single_line(err, 240);
+                if preview.is_empty() {
+                    format!("{base} errored in {elapsed}")
+                } else {
+                    format!("{base} errored in {elapsed}: {preview}")
+                }
+            }
+            AgentStatus::Shutdown => format!("{base} shutdown in {elapsed}"),
+            AgentStatus::NotFound => return,
+        };
+
+        session.notify_background_event(turn, message).await;
+    }
+
+    fn agent_label(agent_type: Option<&str>, agent_name: Option<&str>) -> String {
+        match (agent_type, agent_name) {
+            (Some(agent_type), Some(agent_name)) => format!("{agent_type}/{agent_name}"),
+            (Some(agent_type), None) => agent_type.to_string(),
+            (None, Some(agent_name)) => agent_name.to_string(),
+            (None, None) => "default".to_string(),
+        }
+    }
+
+    fn format_elapsed(elapsed: Duration) -> String {
+        let secs = elapsed.as_secs_f64();
+        if secs < 1.0 {
+            format!("{:.0}ms", secs * 1000.0)
+        } else {
+            format!("{secs:.1}s")
+        }
+    }
+
+    fn preview_single_line(text: &str, max_chars: usize) -> String {
+        let mut out = String::with_capacity(max_chars.min(text.len()));
+        let mut count = 0usize;
+        for ch in text.chars() {
+            if ch == '\n' || ch == '\r' {
+                break;
+            }
+            out.push(ch);
+            count += 1;
+            if count >= max_chars {
+                break;
+            }
+        }
+        out.trim().to_string()
+    }
 }
 
 mod send_input {
@@ -592,6 +818,10 @@ fn build_agent_spawn_config(
 ) -> Result<Config, FunctionCallError> {
     let base_config = turn.config.clone();
     let mut config = (*base_config).clone();
+    // Reset runtime allow/deny to the global policy so spawned agents
+    // don't inherit a parent's narrowed tool list.
+    config.tool_allowlist = config.tool_allowlist_policy.clone();
+    config.tool_denylist = config.tool_denylist_policy.clone();
     config.base_instructions = Some(base_instructions.text.clone());
     config.model = Some(turn.model_info.slug.clone());
     config.model_provider = turn.provider.clone();
@@ -617,7 +847,7 @@ fn build_agent_spawn_config(
 
     // If the new agent will be at max depth:
     if exceeds_thread_spawn_depth_limit(child_depth + 1) {
-        config.features.disable(Feature::Collab);
+        config.features.disable(Feature::FnMultiAgents);
     }
 
     Ok(config)
@@ -631,9 +861,12 @@ mod tests {
     use crate::agent::MAX_THREAD_SPAWN_DEPTH;
     use crate::built_in_model_providers;
     use crate::codex::make_session_and_context;
+    use crate::codex::make_session_and_context_with_rx;
     use crate::config::types::ShellEnvironmentPolicy;
     use crate::function_tool::FunctionCallError;
     use crate::protocol::AskForApproval;
+    use crate::protocol::BackgroundEventEvent;
+    use crate::protocol::EventMsg;
     use crate::protocol::Op;
     use crate::protocol::SandboxPolicy;
     use crate::protocol::SessionSource;
@@ -648,6 +881,7 @@ mod tests {
     use std::sync::Arc;
     use std::time::Duration;
     use tokio::sync::Mutex;
+    use tokio::sync::watch;
     use tokio::time::timeout;
 
     fn invocation(
@@ -679,6 +913,29 @@ mod tests {
         )
     }
 
+    #[tokio::test]
+    async fn build_agent_spawn_config_resets_tool_policy() {
+        let (_session, mut turn) = make_session_and_context().await;
+        let mut base_config = (*turn.config).clone();
+        base_config.tool_allowlist_policy =
+            Some(vec!["shell".to_string(), "read_file".to_string()]);
+        base_config.tool_allowlist = Some(vec!["spawn_agent".to_string()]);
+        base_config.tool_denylist_policy = Some(vec!["apply_patch".to_string()]);
+        base_config.tool_denylist = Some(vec!["shell".to_string()]);
+        turn.config = Arc::new(base_config.clone());
+
+        let base_instructions = BaseInstructions::default();
+        let config = build_agent_spawn_config(&base_instructions, &turn, 0).expect("spawn config");
+        assert_eq!(
+            config.tool_allowlist, base_config.tool_allowlist_policy,
+            "spawned agents should use policy allowlist"
+        );
+        assert_eq!(
+            config.tool_denylist, base_config.tool_denylist_policy,
+            "spawned agents should use policy denylist"
+        );
+    }
+
     #[tokio::test]
     async fn handler_rejects_non_function_payloads() {
         let (session, turn) = make_session_and_context().await;
@@ -766,6 +1023,8 @@ mod tests {
         turn.session_source = SessionSource::SubAgent(SubAgentSource::ThreadSpawn {
             parent_thread_id: session.conversation_id,
             depth: MAX_THREAD_SPAWN_DEPTH,
+            agent_type: None,
+            agent_name: None,
         });
 
         let invocation = invocation(
@@ -785,6 +1044,77 @@ mod tests {
         );
     }
 
+    #[tokio::test]
+    async fn spawn_agent_rejects_unknown_model_override() {
+        let (mut session, turn) = make_session_and_context().await;
+        let manager = thread_manager();
+        session.services.agent_control = manager.agent_control();
+
+        let invocation = invocation(
+            Arc::new(session),
+            Arc::new(turn),
+            "spawn_agent",
+            function_payload(json!({
+                "message": "hello",
+                "model": "nonexistent-model"
+            })),
+        );
+        let Err(err) = CollabHandler.handle(invocation).await else {
+            panic!("spawn should fail on unknown model override");
+        };
+        match err {
+            FunctionCallError::RespondToModel(message) => {
+                assert!(message.starts_with("Model 'nonexistent-model' not found."));
+            }
+            other => panic!("unexpected error: {other:?}"),
+        }
+    }
+
+    #[tokio::test]
+    async fn status_relay_emits_background_events_on_status_changes() {
+        let (session, turn, rx_event) = make_session_and_context_with_rx().await;
+        let receiver_thread_id = ThreadId::new();
+
+        let (tx, status_rx) = watch::channel(AgentStatus::PendingInit);
+        spawn::spawn_status_relay_task(
+            session.clone(),
+            turn.clone(),
+            "call-xyz".to_string(),
+            receiver_thread_id,
+            Some("worker".to_string()),
+            None,
+            status_rx,
+        );
+
+        // Drive status changes.
+        tokio::task::yield_now().await;
+        tx.send(AgentStatus::Running).expect("send running");
+        tokio::task::yield_now().await;
+        tx.send(AgentStatus::Completed(Some("done\nmore".to_string())))
+            .expect("send completed");
+
+        let mut saw_completed = false;
+        let deadline = Duration::from_secs(2);
+        let read = async move {
+            while !saw_completed {
+                let event = rx_event.recv().await.expect("event");
+                let EventMsg::BackgroundEvent(BackgroundEventEvent { message }) = event.msg else {
+                    continue;
+                };
+                if message.contains("completed") {
+                    saw_completed = true;
+                    assert!(message.contains(&receiver_thread_id.to_string()));
+                    assert!(message.contains("[call-xyz]"));
+                    assert!(message.contains("done"));
+                    assert!(!message.contains('\n'));
+                }
+            }
+        };
+        timeout(deadline, read)
+            .await
+            .expect("background events should arrive");
+    }
+
     #[tokio::test]
     async fn send_input_rejects_empty_message() {
         let (session, turn) = make_session_and_context().await;
