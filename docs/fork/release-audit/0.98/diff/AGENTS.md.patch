diff --git a/AGENTS.md b/AGENTS.md
index 77c48ddba..8ee4d35b4 100644
--- a/AGENTS.md
+++ b/AGENTS.md
@@ -14,7 +14,27 @@ In the codex-rs folder where the rust code lives:
 - When possible, make `match` statements exhaustive and avoid wildcard arms.
 - When writing tests, prefer comparing the equality of entire objects over fields one by one.
 - When making a change that adds or changes an API, ensure that the documentation in the `docs/` folder is up to date if applicable.
+- Any new or changed fork-specific behavior must be covered by tests (unit/integration/snapshot) when feasible.
 - If you change `ConfigToml` or nested config types, run `just write-config-schema` to update `codex-rs/core/config.schema.json`.
+- When delegating analysis-only tasks via orchestrator, prefer `explorer` agents (codebase questions, read-only investigation). Use `worker` agents only when you want them to execute changes or perform implementation work.
+
+## Upstream integration workflow (fork/colab-agents)
+
+When integrating upstream changes into the fork, follow this process:
+
+1. **Commit-by-commit only.** Analyze and integrate upstream changes strictly one commit at a time.
+2. **Analyze → plan → confirm → implement.** For each commit, first produce a deep analysis and an integration plan; only implement after explicit confirmation.
+3. **Track status without removing commits.** Update `docs/fork/upstream-main-commits.md` by marking each commit with status and a short integration note (clean cherry-pick vs. manual adaptation). Do not remove commits from the list.
+4. **Canonical-first, fork-preserving.** Prefer upstream behavior as the default, but adapt as needed to preserve and improve fork-specific functionality.
+
+References:
+- `docs/fork/diff-fork-vs-main.md` (complete diff analysis + recommendations)
+- `docs/fork/fork-update-plan.md` (plan of record for fork updates)
+- `docs/fork/task-fork-update-plan.md` (task definition + scope)
+
+Base update guidance:
+- Prefer release tags (e.g. `rust-vX.Y.Z`) as the canonical base for `main`.
+- Only track `upstream/main` directly if explicitly requested.
 
 Run `just fmt` (in `codex-rs` directory) automatically after you have finished making Rust code changes; do not ask for approval to run it. Additionally, run the tests:
 
@@ -23,6 +43,27 @@ Run `just fmt` (in `codex-rs` directory) automatically after you have finished m
 
 Before finalizing a large change to `codex-rs`, run `just fix -p <project>` (in `codex-rs` directory) to fix any linter issues in the code. Prefer scoping with `-p` to avoid slow workspace‑wide Clippy builds; only run `just fix` without `-p` if you changed shared crates.
 
+## Generated artifacts (do not hand-edit)
+
+- `codex-rs/app-server-protocol/schema/**` and schema fixtures are generated.
+- Rebuild with `just write-app-server-schema` after protocol changes.
+- Avoid manual edits; regenerate instead.
+
+## Version alignment
+
+When the base release changes:
+- Update `codex-rs/Cargo.toml` workspace version.
+- Update any TUI snapshots that embed the version string.
+
+## Fork-core change checklist (diff-minimizing)
+
+- Keep fork changes behind `fn_multi_agents` and avoid touching unrelated upstream paths.
+- Use fork markers for inline edits: `// === FORK: ...`.
+- Update docs when behavior changes:
+  - `docs/fork/colab-agents.md` (fork rationale/behavior)
+  - `docs/config.md` (config/schema behavior)
+- If `ConfigToml`/config types change: run `just write-config-schema`.
+
 ## TUI style conventions
 
 See `codex-rs/tui/styles.md`.
@@ -112,43 +153,3 @@ If you don’t have the tool:
   let request = mock.single_request();
   // assert using request.function_call_output(call_id) or request.json_body() or other helpers.
   ```
-
-## App-server API Development Best Practices
-
-These guidelines apply to app-server protocol work in `codex-rs`, especially:
-
-- `app-server-protocol/src/protocol/common.rs`
-- `app-server-protocol/src/protocol/v2.rs`
-- `app-server/README.md`
-
-### Core Rules
-
-- All active API development should happen in app-server v2. Do not add new API surface area to v1.
-- Follow payload naming consistently:
-  `*Params` for request payloads, `*Response` for responses, and `*Notification` for notifications.
-- Expose RPC methods as `<resource>/<method>` and keep `<resource>` singular (for example, `thread/read`, `app/list`).
-- Always expose fields as camelCase on the wire with `#[serde(rename_all = "camelCase")]` unless a tagged union or explicit compatibility requirement needs a targeted rename.
-- Always set `#[ts(export_to = "v2/")]` on v2 request/response/notification types so generated TypeScript lands in the correct namespace.
-- Never use `#[serde(skip_serializing_if = "Option::is_none")]` for v2 API payload fields.
-  Exception: client->server requests that intentionally have no params may use:
-  `params: #[ts(type = "undefined")] #[serde(skip_serializing_if = "Option::is_none")] Option<()>`.
-- For client->server JSON-RPC request payloads (`*Params`) only, every optional field must be annotated with `#[ts(optional = nullable)]`. Do not use `#[ts(optional = nullable)]` outside client->server request payloads (`*Params`).
-- For client->server JSON-RPC request payloads only, and you want to express a boolean field where omission means `false`, use `#[serde(default, skip_serializing_if = "std::ops::Not::not")] pub field: bool` over `Option<bool>`.
-- For new list methods, implement cursor pagination by default:
-  request fields `pub cursor: Option<String>` and `pub limit: Option<u32>`,
-  response fields `pub data: Vec<...>` and `pub next_cursor: Option<String>`.
-- Keep Rust and TS wire renames aligned. If a field or variant uses `#[serde(rename = "...")]`, add matching `#[ts(rename = "...")]`.
-- For discriminated unions, use explicit tagging in both serializers:
-  `#[serde(tag = "type", ...)]` and `#[ts(tag = "type", ...)]`.
-- Prefer plain `String` IDs at the API boundary (do UUID parsing/conversion internally if needed).
-- Timestamps should be integer Unix seconds (`i64`) and named `*_at` (for example, `created_at`, `updated_at`, `resets_at`).
-- For experimental API surface area:
-  use `#[experimental("method/or/field")]`, derive `ExperimentalApi` when field-level gating is needed, and use `inspect_params: true` in `common.rs` when only some fields of a method are experimental.
-
-### Development Workflow
-
-- Update docs/examples when API behavior changes (at minimum `app-server/README.md`).
-- Regenerate schema fixtures when API shapes change:
-  `just write-app-server-schema`
-  (and `just write-app-server-schema --experimental` when experimental API fixtures are affected).
-- Validate with `cargo test -p codex-app-server-protocol`.
