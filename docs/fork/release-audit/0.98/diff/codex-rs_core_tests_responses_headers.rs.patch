diff --git a/codex-rs/core/tests/responses_headers.rs b/codex-rs/core/tests/responses_headers.rs
index 9e70264bf..ca3e45947 100644
--- a/codex-rs/core/tests/responses_headers.rs
+++ b/codex-rs/core/tests/responses_headers.rs
@@ -440,14 +440,88 @@ async fn responses_stream_includes_turn_metadata_header_for_git_workspace_e2e()
         responses::ev_response_created("resp-1"),
         responses::ev_completed("resp-1"),
     ]);
+    let provider = ModelProviderInfo {
+        name: "mock".into(),
+        base_url: Some(format!("{}/v1", server.uri())),
+        env_key: None,
+        env_key_instructions: None,
+        experimental_bearer_token: None,
+        wire_api: WireApi::Responses,
+        query_params: None,
+        http_headers: None,
+        env_http_headers: None,
+        request_max_retries: Some(0),
+        stream_max_retries: Some(0),
+        stream_idle_timeout_ms: Some(5_000),
+        requires_openai_auth: false,
+        supports_websockets: false,
+    };
 
-    let test = test_codex().build(&server).await.expect("build test codex");
-    let cwd = test.cwd_path();
+    let codex_home = TempDir::new().expect("failed to create TempDir");
+    let mut config = load_default_config_for_test(&codex_home).await;
+    config.model_provider_id = provider.name.clone();
+    config.model_provider = provider.clone();
+    let effort = config.model_reasoning_effort;
+    let summary = config.model_reasoning_summary;
+    let model = ModelsManager::get_model_offline(config.model.as_deref());
+    config.model = Some(model.clone());
+    let config = Arc::new(config);
+
+    let conversation_id = ThreadId::new();
+    let auth_mode = AuthMode::Chatgpt;
+    let session_source =
+        SessionSource::SubAgent(SubAgentSource::Other("turn-metadata-e2e".to_string()));
+    let model_info = ModelsManager::construct_model_info_offline(model.as_str(), &config);
+    let otel_manager = OtelManager::new(
+        conversation_id,
+        model.as_str(),
+        model_info.slug.as_str(),
+        None,
+        Some("test@test.com".to_string()),
+        Some(auth_mode),
+        false,
+        "test".to_string(),
+        session_source.clone(),
+    );
+
+    let client = ModelClient::new(
+        Arc::clone(&config),
+        None,
+        model_info,
+        otel_manager,
+        provider,
+        effort,
+        summary,
+        conversation_id,
+        session_source,
+        TransportManager::new(),
+    );
+
+    let workspace = TempDir::new().expect("workspace tempdir");
+    let cwd = workspace.path();
+
+    let mut prompt = Prompt::default();
+    prompt.input = vec![ResponseItem::Message {
+        id: None,
+        role: "user".into(),
+        content: vec![ContentItem::InputText {
+            text: "hello".into(),
+        }],
+        end_turn: None,
+        phase: None,
+    }];
 
     let first_request = responses::mount_sse_once(&server, response_body.clone()).await;
-    test.submit_turn("hello")
+    let mut first_session = client.new_session(Some(cwd.to_path_buf()));
+    let mut first_stream = first_session
+        .stream(&prompt)
         .await
-        .expect("submit first turn prompt");
+        .expect("stream first turn");
+    while let Some(event) = first_stream.next().await {
+        if matches!(event, Ok(ResponseEvent::Completed { .. })) {
+            break;
+        }
+    }
     assert_eq!(
         first_request
             .single_request()
@@ -497,13 +571,21 @@ async fn responses_stream_includes_turn_metadata_header_for_git_workspace_e2e()
         .trim()
         .to_string();
 
+    let repo_root = std::fs::canonicalize(cwd)
+        .unwrap_or_else(|_| cwd.to_path_buf())
+        .to_string_lossy()
+        .into_owned();
     let deadline = tokio::time::Instant::now() + std::time::Duration::from_secs(5);
     loop {
         let request_recorder = responses::mount_sse_once(&server, response_body.clone()).await;
+        let mut session = client.new_session(Some(cwd.to_path_buf()));
         tokio::time::sleep(std::time::Duration::from_millis(50)).await;
-        test.submit_turn("hello")
-            .await
-            .expect("submit post-git turn prompt");
+        let mut stream = session.stream(&prompt).await.expect("stream post-git turn");
+        while let Some(event) = stream.next().await {
+            if matches!(event, Ok(ResponseEvent::Completed { .. })) {
+                break;
+            }
+        }
 
         let maybe_header = request_recorder
             .single_request()
@@ -511,14 +593,11 @@ async fn responses_stream_includes_turn_metadata_header_for_git_workspace_e2e()
         if let Some(header_value) = maybe_header {
             let parsed: serde_json::Value = serde_json::from_str(&header_value)
                 .expect("x-codex-turn-metadata should be valid JSON");
-            let workspaces = parsed
+            let workspace = parsed
                 .get("workspaces")
                 .and_then(serde_json::Value::as_object)
-                .expect("metadata should include workspaces");
-            let workspace = workspaces
-                .values()
-                .next()
-                .expect("metadata should include at least one workspace entry");
+                .and_then(|workspaces| workspaces.get(&repo_root))
+                .expect("metadata should include cwd repo root workspace entry");
 
             assert_eq!(
                 workspace
