diff --git a/codex-rs/tui/src/streaming/controller.rs b/codex-rs/tui/src/streaming/controller.rs
index 6117485ad..462962e98 100644
--- a/codex-rs/tui/src/streaming/controller.rs
+++ b/codex-rs/tui/src/streaming/controller.rs
@@ -4,8 +4,6 @@ use crate::render::line_utils::prefix_lines;
 use crate::style::proposed_plan_style;
 use ratatui::prelude::Stylize;
 use ratatui::text::Line;
-use std::time::Duration;
-use std::time::Instant;
 
 use super::StreamState;
 
@@ -73,28 +71,6 @@ impl StreamController {
         (self.emit(step), self.state.is_idle())
     }
 
-    /// Step animation: commit at most `max_lines` queued lines.
-    ///
-    /// This is intended for adaptive catch-up drains. Callers should keep `max_lines` bounded; a
-    /// very large value can collapse perceived animation into a single jump.
-    pub(crate) fn on_commit_tick_batch(
-        &mut self,
-        max_lines: usize,
-    ) -> (Option<Box<dyn HistoryCell>>, bool) {
-        let step = self.state.drain_n(max_lines.max(1));
-        (self.emit(step), self.state.is_idle())
-    }
-
-    /// Returns the current number of queued lines waiting to be displayed.
-    pub(crate) fn queued_lines(&self) -> usize {
-        self.state.queued_len()
-    }
-
-    /// Returns the age of the oldest queued line.
-    pub(crate) fn oldest_queued_age(&self, now: Instant) -> Option<Duration> {
-        self.state.oldest_queued_age(now)
-    }
-
     fn emit(&mut self, lines: Vec<Line<'static>>) -> Option<Box<dyn HistoryCell>> {
         if lines.is_empty() {
             return None;
@@ -166,28 +142,6 @@ impl PlanStreamController {
         (self.emit(step, false), self.state.is_idle())
     }
 
-    /// Step animation: commit at most `max_lines` queued lines.
-    ///
-    /// This is intended for adaptive catch-up drains. Callers should keep `max_lines` bounded; a
-    /// very large value can collapse perceived animation into a single jump.
-    pub(crate) fn on_commit_tick_batch(
-        &mut self,
-        max_lines: usize,
-    ) -> (Option<Box<dyn HistoryCell>>, bool) {
-        let step = self.state.drain_n(max_lines.max(1));
-        (self.emit(step, false), self.state.is_idle())
-    }
-
-    /// Returns the current number of queued plan lines waiting to be displayed.
-    pub(crate) fn queued_lines(&self) -> usize {
-        self.state.queued_len()
-    }
-
-    /// Returns the age of the oldest queued plan line.
-    pub(crate) fn oldest_queued_age(&self, now: Instant) -> Option<Duration> {
-        self.state.oldest_queued_age(now)
-    }
-
     fn emit(
         &mut self,
         lines: Vec<Line<'static>>,
