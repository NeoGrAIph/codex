diff --git a/codex-rs/codex-api/src/endpoint/aggregate.rs b/codex-rs/codex-api/src/endpoint/chat.rs
similarity index 54%
rename from codex-rs/codex-api/src/endpoint/aggregate.rs
rename to codex-rs/codex-api/src/endpoint/chat.rs
index ac0cee904..b183597d6 100644
--- a/codex-rs/codex-api/src/endpoint/aggregate.rs
+++ b/codex-rs/codex-api/src/endpoint/chat.rs
@@ -1,21 +1,111 @@
+use crate::ChatRequest;
+use crate::auth::AuthProvider;
+use crate::common::Prompt as ApiPrompt;
 use crate::common::ResponseEvent;
 use crate::common::ResponseStream;
+use crate::endpoint::streaming::StreamingClient;
 use crate::error::ApiError;
+use crate::provider::Provider;
+use crate::provider::WireApi;
+use crate::sse::chat::spawn_chat_stream;
+use crate::telemetry::SseTelemetry;
+use codex_client::HttpTransport;
+use codex_client::RequestCompression;
+use codex_client::RequestTelemetry;
 use codex_protocol::models::ContentItem;
 use codex_protocol::models::ReasoningItemContent;
 use codex_protocol::models::ResponseItem;
+use codex_protocol::protocol::SessionSource;
 use futures::Stream;
+use http::HeaderMap;
+use serde_json::Value;
 use std::collections::VecDeque;
 use std::pin::Pin;
+use std::sync::Arc;
 use std::task::Context;
 use std::task::Poll;
 
+pub struct ChatClient<T: HttpTransport, A: AuthProvider> {
+    streaming: StreamingClient<T, A>,
+}
+
+impl<T: HttpTransport, A: AuthProvider> ChatClient<T, A> {
+    pub fn new(transport: T, provider: Provider, auth: A) -> Self {
+        Self {
+            streaming: StreamingClient::new(transport, provider, auth),
+        }
+    }
+
+    pub fn with_telemetry(
+        self,
+        request: Option<Arc<dyn RequestTelemetry>>,
+        sse: Option<Arc<dyn SseTelemetry>>,
+    ) -> Self {
+        Self {
+            streaming: self.streaming.with_telemetry(request, sse),
+        }
+    }
+
+    pub async fn stream_request(&self, request: ChatRequest) -> Result<ResponseStream, ApiError> {
+        self.stream(request.body, request.headers).await
+    }
+
+    pub async fn stream_prompt(
+        &self,
+        model: &str,
+        prompt: &ApiPrompt,
+        conversation_id: Option<String>,
+        session_source: Option<SessionSource>,
+    ) -> Result<ResponseStream, ApiError> {
+        use crate::requests::ChatRequestBuilder;
+
+        let request =
+            ChatRequestBuilder::new(model, &prompt.instructions, &prompt.input, &prompt.tools)
+                .conversation_id(conversation_id)
+                .session_source(session_source)
+                .build(self.streaming.provider())?;
+
+        self.stream_request(request).await
+    }
+
+    fn path(&self) -> &'static str {
+        match self.streaming.provider().wire {
+            WireApi::Chat => "chat/completions",
+            _ => "responses",
+        }
+    }
+
+    pub async fn stream(
+        &self,
+        body: Value,
+        extra_headers: HeaderMap,
+    ) -> Result<ResponseStream, ApiError> {
+        self.streaming
+            .stream(
+                self.path(),
+                body,
+                extra_headers,
+                RequestCompression::None,
+                spawn_chat_stream,
+                None,
+            )
+            .await
+    }
+}
+
+#[derive(Copy, Clone, Eq, PartialEq)]
+pub enum AggregateMode {
+    AggregatedOnly,
+    Streaming,
+}
+
 /// Stream adapter that merges token deltas into a single assistant message per turn.
 pub struct AggregatedStream {
     inner: ResponseStream,
     cumulative: String,
     cumulative_reasoning: String,
     pending: VecDeque<ResponseEvent>,
+    mode: AggregateMode,
 }
 
 impl Stream for AggregatedStream {
@@ -32,7 +122,7 @@ impl Stream for AggregatedStream {
             match Pin::new(&mut this.inner).poll_next(cx) {
                 Poll::Pending => return Poll::Pending,
                 Poll::Ready(None) => return Poll::Ready(None),
-                Poll::Ready(Some(Err(err))) => return Poll::Ready(Some(Err(err))),
+                Poll::Ready(Some(Err(e))) => return Poll::Ready(Some(Err(e))),
                 Poll::Ready(Some(Ok(ResponseEvent::OutputItemDone(item)))) => {
                     let is_assistant_message = matches!(
                         &item,
@@ -40,16 +130,29 @@ impl Stream for AggregatedStream {
                     );
 
                     if is_assistant_message {
-                        if this.cumulative.is_empty()
-                            && let ResponseItem::Message { content, .. } = &item
-                            && let Some(text) = content.iter().find_map(|c| match c {
-                                ContentItem::OutputText { text } => Some(text),
-                                _ => None,
-                            })
-                        {
-                            this.cumulative.push_str(text);
+                        match this.mode {
+                            AggregateMode::AggregatedOnly => {
+                                if this.cumulative.is_empty()
+                                    && let ResponseItem::Message { content, .. } = &item
+                                    && let Some(text) = content.iter().find_map(|c| match c {
+                                        ContentItem::OutputText { text } => Some(text),
+                                        _ => None,
+                                    })
+                                {
+                                    this.cumulative.push_str(text);
+                                }
+                                continue;
+                            }
+                            AggregateMode::Streaming => {
+                                if this.cumulative.is_empty() {
+                                    return Poll::Ready(Some(Ok(ResponseEvent::OutputItemDone(
+                                        item,
+                                    ))));
+                                } else {
+                                    continue;
+                                }
+                            }
                         }
-                        continue;
                     }
 
                     return Poll::Ready(Some(Ok(ResponseEvent::OutputItemDone(item))));
@@ -113,20 +216,35 @@ impl Stream for AggregatedStream {
                         token_usage,
                     })));
                 }
-                Poll::Ready(Some(Ok(ResponseEvent::Created))) => continue,
+                Poll::Ready(Some(Ok(ResponseEvent::Created))) => {
+                    continue;
+                }
                 Poll::Ready(Some(Ok(ResponseEvent::OutputTextDelta(delta)))) => {
                     this.cumulative.push_str(&delta);
-                    continue;
+                    if matches!(this.mode, AggregateMode::Streaming) {
+                        return Poll::Ready(Some(Ok(ResponseEvent::OutputTextDelta(delta))));
+                    } else {
+                        continue;
+                    }
                 }
                 Poll::Ready(Some(Ok(ResponseEvent::ReasoningContentDelta {
                     delta,
-                    content_index: _,
+                    content_index,
                 }))) => {
                     this.cumulative_reasoning.push_str(&delta);
-                    continue;
+                    if matches!(this.mode, AggregateMode::Streaming) {
+                        return Poll::Ready(Some(Ok(ResponseEvent::ReasoningContentDelta {
+                            delta,
+                            content_index,
+                        })));
+                    } else {
+                        continue;
+                    }
                 }
                 Poll::Ready(Some(Ok(ResponseEvent::ReasoningSummaryDelta { .. }))) => continue,
-                Poll::Ready(Some(Ok(ResponseEvent::ReasoningSummaryPartAdded { .. }))) => continue,
+                Poll::Ready(Some(Ok(ResponseEvent::ReasoningSummaryPartAdded { .. }))) => {
+                    continue;
+                }
                 Poll::Ready(Some(Ok(ResponseEvent::OutputItemAdded(item)))) => {
                     return Poll::Ready(Some(Ok(ResponseEvent::OutputItemAdded(item))));
                 }
@@ -137,21 +255,28 @@ impl Stream for AggregatedStream {
 
 pub trait AggregateStreamExt {
     fn aggregate(self) -> AggregatedStream;
+
+    fn streaming_mode(self) -> ResponseStream;
 }
 
 impl AggregateStreamExt for ResponseStream {
     fn aggregate(self) -> AggregatedStream {
-        AggregatedStream::new(self)
+        AggregatedStream::new(self, AggregateMode::AggregatedOnly)
+    }
+
+    fn streaming_mode(self) -> ResponseStream {
+        self
     }
 }
 
 impl AggregatedStream {
-    fn new(inner: ResponseStream) -> Self {
+    fn new(inner: ResponseStream, mode: AggregateMode) -> Self {
         AggregatedStream {
             inner,
             cumulative: String::new(),
             cumulative_reasoning: String::new(),
             pending: VecDeque::new(),
+            mode,
         }
     }
 }
