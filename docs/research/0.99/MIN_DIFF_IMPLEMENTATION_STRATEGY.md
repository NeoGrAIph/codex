# Стратегия внедрения с минимальным diff

## Цель

Сделать новый функционал в форке так, чтобы:

1. минимизировать расхождение с upstream;
2. упростить последующие обновления на новые `rust-v*` теги;
3. не смешивать feature work с историческим техническим долгом.

## 1) Стартовая ветка

Рекомендуемый старт:

```bash
git switch -c fork/<feature>-0.99 rust-v0.99.0
```

Почему не брать как основу текущие `fork/*` ветки:

- `fork/colab-agents` и `fork/multi-agent` уже имеют >1000 измененных файлов относительно `rust-v0.99.0`.
- Любая новая фича поверх такого стека автоматически получает высокий конфликтный хвост.

## 2) Patch stack: разделение на слои

Рекомендуемый порядок коммитов/PR-чанков:

1. `prep`: только инфраструктура фичи (feature flag, wiring, без изменения поведения по умолчанию).
2. `core`: минимальная бизнес-логика.
3. `surface`: TUI/CLI/app-server интеграция (только если реально нужна).
4. `tests`: unit/integration/snapshot.
5. `docs/schema`: только обязательные регенерации и доки.

Правило: каждый слой должен быть mergeable отдельно и иметь свой набор проверок.

## 3) Upstream-first правила

1. Не менять дефолтное поведение без обязательной причины.
2. Не вводить fork-only API в `v1`; для app-server использовать только `v2`.
3. Предпочитать feature flag вместо hard switch.
4. Если upstream уже имеет похожую возможность, адаптироваться к его форме вместо своей.

## 4) Работа с существующими fork-наработками

Если нужно переиспользовать код из `fork/multi-agent` / `fork/colab-agents`:

1. брать только точечные коммиты (`cherry-pick -n <sha>`),
2. сразу чистить лишние изменения,
3. не переносить автоматически документацию/patch artifacts из старых audit-пакетов,
4. избегать массового копирования generated файлов без регенерации на текущей базе.

## 5) Политика изменения файлов

1. Один логический шаг -> минимальный набор файлов.
2. Не мешать в один коммит: функционал + массовый рефактор + format churn.
3. Для generated-файлов:
   - менять только через генератор (`just write-config-schema`, `just write-app-server-schema`),
   - в коммите явно отмечать, что файл generated.

## 6) Метрики "минимального diff"

Перед merge по каждой задаче фиксировать:

1. `git diff --name-only rust-v0.99.0..HEAD | wc -l`
2. число затронутых top-level зон (`core/tui/app-server-protocol/...`)
3. наличие/отсутствие изменений в CI/release/vendor
4. долю generated файлов в diff

Если diff начинает расти непропорционально, разбивать задачу на меньшие PR-чанки.

## 7) Режим синхронизации с upstream

Рекомендуемый цикл:

1. Регулярно подтягивать `upstream/main`.
2. Держать отдельный документ baseline для каждого этапа (`tag`, `commit`, `дата`).
3. Перед крупным merge делать replay-проверку на свежем upstream:

```bash
git fetch upstream
git rebase upstream/main
```

(или merge-политика команды, если rebase не принят).

## 8) Когда допустим больший diff

Допустимо расширять diff только если это прямо нужно для фичи и заранее согласовано:

1. изменение протокола + регенерация схем;
2. изменение конфиг-модели + регенерация config schema;
3. безопасность/sandbox/policy fix с обязательными тестами.

Во всех остальных случаях "большой diff" считается smell и требует декомпозиции.

